import{_ as i,l as a,ac as e,k as t}from"./chunks/framework.CrgDeNu1.js";const E=JSON.parse('{"title":"组合式Api","description":"","frontmatter":{},"headers":[],"relativePath":"pit/vue/vue基础知识/组合式Api.md","filePath":"pit/vue/vue基础知识/组合式Api.md","lastUpdated":1729244301000}'),p={name:"pit/vue/vue基础知识/组合式Api.md"};function n(h,s,l,k,d,r){return t(),a("div",null,s[0]||(s[0]=[e(`<h1 id="组合式api" tabindex="-1">组合式Api <a class="header-anchor" href="#组合式api" aria-label="Permalink to &quot;组合式Api&quot;">​</a></h1><p>用处：解决组件选项(<code>data,watch</code>)代码量过多</p><p>注意：不要再<code>Setup</code>中使用<code>this</code></p><h2 id="setup-选项" tabindex="-1">Setup 选项 <a class="header-anchor" href="#setup-选项" aria-label="Permalink to &quot;Setup 选项&quot;">​</a></h2><p><code>Setup(props,context)</code></p><ul><li><p>参数：</p><p><code>props</code>:如字面意思一样 值得注意的是<code>props</code>被解构后会失去prop的响应性 如果需要使用的话 请使用 <code>toRefs</code> 函数来完成此操作</p><p><code>context</code>：是一个普通的js对象 此对象中包含了其他可能在setup中出现的值<code>attrs slots emit expose</code> expose(option)可以将此option 暴露给父组件</p></li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">导入的方法</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">provide</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">inject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">reactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">toRefs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">readonly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`vue\`</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readonly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:是将通过ref 或reactive定义好的数据进行拷贝后变为仅可读的数据，不可进行修改，即无响应</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//可导入的方法还有生命周期函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">推荐一种写法：只有我们明确知道要转换的对象内部的字段名称我们才使用reactive，否则就一律使用ref，从而降低在语法选择上的心智负担</span></span></code></pre></div><h3 id="setup-选项中的变量" tabindex="-1">Setup 选项中的变量 <a class="header-anchor" href="#setup-选项中的变量" aria-label="Permalink to &quot;Setup 选项中的变量&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    -</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> reactive 函数 :接收一个普通的对象传入，把对象数据转化为响应式对象并返回</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    -</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ref 函数 :接受一个简单类型或者复杂类型的传入并返回一个响应式且可变的 ref 对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    -</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> toRefs 函数:使用 toRefs函数 可以保证该对象展开的每个属性都是响应式的</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    -</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> computed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:根据现有响应式数据经过一定的计算得到全新的数据</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    -</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(counter,callback{},option{}) 侦听器 :基于响应式数据的变化执行回调逻辑，和vue2中的watch的功能完全一致</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        immediate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 为</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">时 运行时就会执行一遍</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        depp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 开启deep</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        为了避免depp模式的出错 state.info.age 可以直接监听对象中的元素</span></span></code></pre></div>`,9)]))}const c=i(p,[["render",n]]);export{E as __pageData,c as default};
